def problemFormulation():
    ap = {'r1', 'r2', 'r3', 'r4', 'r5', 'r6', 'r', 'b'}
    # +-----+-----+-----+
    # | r4,r| r5,b| r6,b|
    # +-----+-----+-----+
    # | r1,r| r2,b| r3,r|
    # +-----+-----+-----+
    regions = {   (0, 0, 1): {'r1', 'r'},
              (1, 0, 1): {'r2', 'b'},
              (2, 0, 1): {'r3', 'r'},
              (0, 1, 1): {'r4', 'r'},
              (1, 1, 1): {'r5', 'b'},
              (2, 1, 1): {'r6', 'b'}
              }

    init_state = [(0,0,1)]

    edges = [   ((0, 0, 1), (1, 0, 1)),
            ((1, 0, 1), (2, 0, 1)),
            ((0, 1, 1), (1, 1, 1)),
            ((1, 1, 1), (2, 1, 1)),
            ((0, 0, 1), (0, 1, 1)),
            ((1, 0, 1), (1, 1, 1)),
            ((2, 0, 1), (2, 1, 1))
            ]
    uni_cost = 0.1

    ap = {'r1', 'r2', 'r3', 'r4', 'r5', 'r6', 'c1', 'c2', 'c3', 'rb', 'gb', 'b'}
    # +-----+-----+-----+
    # | r4,b|r5,rb| r6  |
    # +-----+-----+-----+
    # | c1  | c2  | c3  |
    # +-----+-----+-----+
    # | r1  | r2,b|r3,gb|
    # +-----+-----+-----+

    # no whitespace in atomic proposation
    regions = {   (0, 0, 1): ['r1'],
              (1, 0, 1): ['r2', 'b'],
              (2, 0, 1): ['r3', 'gb'],
              (0, 1, 1): ['c1'],
              (1, 1, 1): ['c2'],
              (2, 1, 1): ['c3'],
              (0, 2, 1): ['r4', 'b'],
              (1, 2, 1): ['r5', 'rb'],
              (2, 2, 1): ['r6']
              }

    init_state = [(0,0,1)]

    edges = [
            ((0, 1, 1), (1, 1, 1)),
            ((1, 1, 1), (2, 1, 1)),
            ((0, 0, 1), (0, 1, 1)),
            ((0, 1, 1), (0, 2, 1)),
            ((1, 0, 1), (1, 1, 1)),
            ((1, 1, 1), (1, 2, 1)),
            ((2, 0, 1), (2, 1, 1)),
            ((2, 1, 1), (2, 2, 1))
            ]
    uni_cost = 0.1

    #formula = '([]<>r4) && ([]<>r3) && ([]<>r6)'  # inspect room r3, r4, r6 infinitely often
    #formula = '<>(rb && <>b) && <>[]r1'               # pick red ball to one basket and visit r1 infinitely often
    #formula =  '<>(rb && <>b) && <>[]r1 && [](rb -> X(!gb U b)) && <>(gb && <>b) && [](gb -> X(!rb U b))'
    formula = '<>(rb && <>(b && r2)) && <>[]r1 && [](rb -> X(!gb U b)) && <>(gb && <>(b && r4)) && [](gb -> X(!rb U b))'

    return regions, init_state, edges, uni_cost, formula